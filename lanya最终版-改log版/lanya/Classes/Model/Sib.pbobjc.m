// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sib.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Sib.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - SibRoot

@implementation SibRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - SibRoot_FileDescriptor

static GPBFileDescriptor *SibRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - M2

@implementation M2

@dynamic oneOfOneOfCase;
@dynamic m1;
@dynamic m2P2;
@dynamic m2P3;
@dynamic m3P3;
@dynamic m4P3;
@dynamic k;

typedef struct M2__storage_ {
  uint32_t _has_storage_[2];
  C3 *m1;
  C3 *m2P2;
  C3P *m2P3;
  C4P *m3P3;
  C3P *m4P3;
  K *k;
} M2__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "m1",
        .dataTypeSpecific.className = GPBStringifySymbol(C3),
        .number = M2_FieldNumber_M1,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(M2__storage_, m1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "m2P2",
        .dataTypeSpecific.className = GPBStringifySymbol(C3),
        .number = M2_FieldNumber_M2P2,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(M2__storage_, m2P2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "m2P3",
        .dataTypeSpecific.className = GPBStringifySymbol(C3P),
        .number = M2_FieldNumber_M2P3,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(M2__storage_, m2P3),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "m3P3",
        .dataTypeSpecific.className = GPBStringifySymbol(C4P),
        .number = M2_FieldNumber_M3P3,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(M2__storage_, m3P3),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "m4P3",
        .dataTypeSpecific.className = GPBStringifySymbol(C3P),
        .number = M2_FieldNumber_M4P3,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(M2__storage_, m4P3),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "k",
        .dataTypeSpecific.className = GPBStringifySymbol(K),
        .number = M2_FieldNumber_K,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(M2__storage_, k),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[M2 class]
                                     rootClass:[SibRoot class]
                                          file:SibRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(M2__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "oneOf",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void M2_ClearOneOfOneOfCase(M2 *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - C3

@implementation C3

@dynamic c1;
@dynamic c2;
@dynamic c3;

typedef struct C3__storage_ {
  uint32_t _has_storage_[1];
  NSData *c1;
  NSData *c2;
  NSData *c3;
} C3__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "c1",
        .dataTypeSpecific.className = NULL,
        .number = C3_FieldNumber_C1,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(C3__storage_, c1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "c2",
        .dataTypeSpecific.className = NULL,
        .number = C3_FieldNumber_C2,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(C3__storage_, c2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "c3",
        .dataTypeSpecific.className = NULL,
        .number = C3_FieldNumber_C3,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(C3__storage_, c3),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[C3 class]
                                     rootClass:[SibRoot class]
                                          file:SibRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(C3__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - C3P

@implementation C3P

@dynamic c1;
@dynamic c2;
@dynamic hasC3, c3;

typedef struct C3P__storage_ {
  uint32_t _has_storage_[1];
  NSData *c1;
  NSData *c2;
  Pair *c3;
} C3P__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "c1",
        .dataTypeSpecific.className = NULL,
        .number = C3P_FieldNumber_C1,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(C3P__storage_, c1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "c2",
        .dataTypeSpecific.className = NULL,
        .number = C3P_FieldNumber_C2,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(C3P__storage_, c2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "c3",
        .dataTypeSpecific.className = GPBStringifySymbol(Pair),
        .number = C3P_FieldNumber_C3,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(C3P__storage_, c3),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[C3P class]
                                     rootClass:[SibRoot class]
                                          file:SibRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(C3P__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - C4P

@implementation C4P

@dynamic c1;
@dynamic c2;
@dynamic c3;
@dynamic hasC4, c4;

typedef struct C4P__storage_ {
  uint32_t _has_storage_[1];
  NSData *c1;
  NSData *c2;
  NSData *c3;
  Pair *c4;
} C4P__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "c1",
        .dataTypeSpecific.className = NULL,
        .number = C4P_FieldNumber_C1,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(C4P__storage_, c1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "c2",
        .dataTypeSpecific.className = NULL,
        .number = C4P_FieldNumber_C2,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(C4P__storage_, c2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "c3",
        .dataTypeSpecific.className = NULL,
        .number = C4P_FieldNumber_C3,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(C4P__storage_, c3),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "c4",
        .dataTypeSpecific.className = GPBStringifySymbol(Pair),
        .number = C4P_FieldNumber_C4,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(C4P__storage_, c4),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[C4P class]
                                     rootClass:[SibRoot class]
                                          file:SibRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(C4P__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - K

@implementation K

@dynamic hasK1K2, k1K2;

typedef struct K__storage_ {
  uint32_t _has_storage_[1];
  Pair *k1K2;
} K__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "k1K2",
        .dataTypeSpecific.className = GPBStringifySymbol(Pair),
        .number = K_FieldNumber_K1K2,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(K__storage_, k1K2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[K class]
                                     rootClass:[SibRoot class]
                                          file:SibRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(K__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Pair

@implementation Pair

@dynamic first;
@dynamic second;

typedef struct Pair__storage_ {
  uint32_t _has_storage_[1];
  NSData *first;
  NSData *second;
} Pair__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "first",
        .dataTypeSpecific.className = NULL,
        .number = Pair_FieldNumber_First,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Pair__storage_, first),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "second",
        .dataTypeSpecific.className = NULL,
        .number = Pair_FieldNumber_Second,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Pair__storage_, second),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Pair class]
                                     rootClass:[SibRoot class]
                                          file:SibRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Pair__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
